<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于头像</title>
      <link href="/2021/09/01/avatar/"/>
      <url>/2021/09/01/avatar/</url>
      
        <content type="html"><![CDATA[<h1 id="弹奏鲁特琴的天使"><a href="#弹奏鲁特琴的天使" class="headerlink" title="弹奏鲁特琴的天使"></a>弹奏鲁特琴的天使</h1><img src="/2021/09/01/avatar/lute_simp.jpg" class><p style="line-height:1.2"></p><p><font size="2">39.5×47cm        |    Renaissance        |    Galleria degli Uffizi</font></p><p>&emsp;&emsp;这幅著名的作品以一位小天使拨弄着鲁特琴的琴弦为特征，是一件遗失的圣坛装饰画的一块碎片；在后期回顾时才加上去的黑暗的背景之下，对下层画面的反射研究揭示出了某个建筑物的一部分，这个音乐小天使应是在其底部站立，参考弗拉·巴托洛梅奥（Fra Bartolomeo）或拉斐尔（Raphael）的某些常见构图的站立方式。</p><p>&emsp;&emsp;在这幅画的黑暗背景之下，下层画面的反射研究还揭示了艺术家罗索·菲奥伦蒂诺（Rosso Fiorentino）的名字和1521年的日期，但不确定是罗索自己的笔迹还是在拆除圣坛画时添加的笔迹以保存对其作者身份的了解。</p><p>&emsp;&emsp;这幅画是罗索·菲奥伦蒂诺对传统主题的原创的重新诠释，而其中显着的现代笔触使作品具有特别生动的效果，作品描绘了小天使非常温柔的形象，显然他对努力弹奏和他体型对比过大的鲁特琴没有信心。</p><p>——DAILYART AUG 20,2021</p><p>原图在这-&gt;<a href="https://s3-eu-west-1.amazonaws.com/dailyartartwork/img-2021070860e6dc99cc6cc">Angel playing the lute</a>(7.8MB,3342×2665)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cx_Oracle操作Oracle数据库(二):代码篇</title>
      <link href="/2021/08/31/cx-Oracle-2/"/>
      <url>/2021/08/31/cx-Oracle-2/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;<a href="/2021/08/30/cx_Oracle_1/" title="上一篇">上一篇</a>讲了cx_Oracle的安装以及相关的环境配置,本篇就来讲讲cx_Oracle这个模块的具体使用方法.<span id="more"></span></p><p>&emsp;&emsp;<em>本文只介绍基本的一些数据库最基本的操作方法,不涉及到连结池、存储过程等操作</em></p><hr><p>详细信息请参阅<a href="https://cx-oracle.readthedocs.io/en/latest/"><font color="lightblue">cx_Oracle官方文档</font></a></p><hr><h2 id="cx-Oracle一些对象的介绍"><a href="#cx-Oracle一些对象的介绍" class="headerlink" title="cx_Oracle一些对象的介绍"></a>cx_Oracle一些对象的介绍</h2><h3 id="在成功连接数据库之后"><a href="#在成功连接数据库之后" class="headerlink" title="在成功连接数据库之后"></a>在成功连接数据库之后</h3><p>在连接上数据库之后,cx_Oracle会返回一个<a href="https://cx-oracle.readthedocs.io/en/latest/api_manual/connection.html#connection-object">Connection对象</a>,该对象用的比较多的就是<code>Connection.cursor()</code>和<code>Connection.close()</code>了,前者是用来返回一个新的<em>cursor</em> 对象,我们进行的CRUD等大部分的操作都要用到<em>cursor</em> 对象来进行操作.后者则是关闭连接的操作,每次执行完程序后,都需要将连接关闭.</p><h3 id="开始前的几个小建议"><a href="#开始前的几个小建议" class="headerlink" title="开始前的几个小建议"></a>开始前的几个小建议</h3><ul><li><p>建立完数据库连接之后,尽量使用try——finally语句,避免因为程序出错而导致数据库连接未被正常关闭的现象的出现.    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conn = cx_Oracle.connect(DB)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    ...<span class="comment"># your codes</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><p>这样一来,即使程序运行出错,最终也会关闭连接.</p></li><li><p>使用<em>cursor</em>游标时也要注意,需要手动关闭游标,不过为了方便,一般有需要到时可以使用with…as…的方法来进行调用，下面的这段代码能够确保一旦代码块完成，游标就会被回收关闭.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cur:</span><br><span class="line">    ...<span class="comment"># cursor operation</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用cx-Oracle"><a href="#使用cx-Oracle" class="headerlink" title="使用cx_Oracle"></a>使用cx_Oracle</h2><h3 id="使用使用cx-Oracle进行查询"><a href="#使用使用cx-Oracle进行查询" class="headerlink" title="使用使用cx_Oracle进行查询"></a>使用使用cx_Oracle进行查询</h3><p>执行完对应sql语句后，游标可以通过按行进行迭代来获取所要查询的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cur:</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cur.execute(sql):</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure><p>同时也可以通过游标对象的fetch()方法来获取数据:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cur:</span><br><span class="line">cur = cur.execute(sql)</span><br><span class="line">result = cur.fetchone()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result))</span><br><span class="line"><span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法首先通过游标<code>cursor.execute()</code>执行sql语句，之后通过<em>cursor</em> 的fetch方法来获取结果，通过打印输出可以看出执行语句获取的结果是以tuple元组的方式返回的，取到数据后就可以进行其他的操作了，而cur也随着代码执行结束自动销毁了.</p><p>&emsp;&emsp;除了用<code>cursor.fetchone()</code>方法之外，还可以用<code>cursor.fetchall()``cursor.fetchmany(num_rows)</code>方法来获取对应行数的数据.</p><p>&emsp;&emsp;如果返回的数据不止一条，数据则会以列表的方式返回，列表中的每一条数据都是一个元组，每个元组表示查询到的一行数据,如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">&quot;LiMing&quot;</span>,<span class="number">12</span>,<span class="number">1</span>),(<span class="string">&quot;LiHu&quot;</span>,<span class="number">13</span>,<span class="number">1</span>),(<span class="string">&quot;XiaoHong&quot;</span>,<span class="number">12</span>,<span class="number">0</span>),(<span class="string">&quot;XiaoHui&quot;</span>,<span class="number">12</span>,<span class="number">0</span>)]</span><br></pre></td></tr></table></figure><p>通过上述方法就能获取到我们执行数据库操作后查询到的结果了.</p><h3 id="使用cx-Oracle进行其他操作（DML、DDL、DCL）"><a href="#使用cx-Oracle进行其他操作（DML、DDL、DCL）" class="headerlink" title="使用cx_Oracle进行其他操作（DML、DDL、DCL）"></a>使用cx_Oracle进行其他操作（DML、DDL、DCL）</h3><p>&emsp;&emsp;进行其他操作一般不需要处理返回结果集，用到的执行函数也是<code>execute()</code>，因此直接编写sql语句再调用execute()方法执行即可.</p><p>&emsp;&emsp;但是有一点需要特别注意，当<code>cur.execute()</code>执行一条 SQL 语句的同时会启动或继续一个事务。默认情况下，cx_Oracle 不会将此事务提交到数据库。方法<code>conn.commit()</code>和<code>conn.rollback()</code>方法可用于显式提交或回滚事务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cursor.execute(<span class="string">&quot;insert ... into ... values ...)</span></span><br><span class="line"><span class="string">connection.commit()</span></span><br></pre></td></tr></table></figure><p>数据库连接conn关闭时，任何<font color="#fdb933">未被提交的事务</font>都会被回滚.</p><h2 id="使用绑定变量-Bind-Variables"><a href="#使用绑定变量-Bind-Variables" class="headerlink" title="使用绑定变量(Bind Variables)"></a>使用绑定变量(Bind Variables)</h2><p>&emsp;&emsp;因为工作中需要对数据进行批量写入，我就进行了python中字符串format的用法对sql语句进行修改:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">insert into classroom values (&#x27;<span class="subst">&#123;name&#125;</span>&#x27;, <span class="subst">&#123;age&#125;</span>,<span class="subst">&#123;sex&#125;</span>)&quot;&quot;&quot;</span></span><br><span class="line">cursor.execute(sql)</span><br></pre></td></tr></table></figure><p>执行也没有问题，但是在我一次查看文档时发现了一段话  </p><p><strong><em>Never concatenate or interpolate user data into SQL statements:</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">did = <span class="number">280</span></span><br><span class="line">dnm = <span class="string">&quot;Facility&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># !! Never do this !!</span></span><br><span class="line">sql = <span class="string">f&quot;&quot;&quot;insert into departments (department_id, department_name)</span></span><br><span class="line"><span class="string">          values (<span class="subst">&#123;did&#125;</span>, &#x27;<span class="subst">&#123;dnm&#125;</span>&#x27;)&quot;&quot;&quot;</span></span><br><span class="line">cursor.execute(sql)</span><br></pre></td></tr></table></figure><p>突然意识到还有sql注入这种东西，直接撞枪口上了，之后看了一下文档，发现更改方式也是很简单，采用的也是预编译的手段，方法是<code>cur.execute(sql,bind_params)</code>，bind_params是一个参数列表，比如之前的插入语句就可以修改为这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">insert into classroom values (:name, :age,:sex)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">bind_params = [<span class="string">&quot;XiaoSe&quot;</span>,<span class="number">8</span>,<span class="number">1</span>]</span><br><span class="line">cur.execute(sql,bind_params)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;绑定变量方式可以按照位置、名称、类型等绑定，详细内容参阅<a href="https://cx-oracle.readthedocs.io/en/latest/user_guide/bind.html#using-bind-variables">Using Bind Variables</a>.</p><p>&emsp;&emsp;使用绑定变量还可以加快大批量sql执行的速度，使得sql语句只用编译一次，每次只需更改变量即可。</p><h2 id="使用过程中遇到的一些错误"><a href="#使用过程中遇到的一些错误" class="headerlink" title="使用过程中遇到的一些错误"></a>使用过程中遇到的一些错误</h2><h3 id="ORA-00911-invalid-character"><a href="#ORA-00911-invalid-character" class="headerlink" title="ORA-00911: invalid character"></a>ORA-00911: invalid character</h3><p>出现这个问题很有可能是sql句末出现了分号<code>;</code>,在通过cx_Oracle对数据库进行操作时，所有的sql语句都不需要加最后的分号,去掉分号再尝试一遍即可.</p><h3 id="ORA-00984-column-not-allowed-here"><a href="#ORA-00984-column-not-allowed-here" class="headerlink" title="ORA-00984: column not allowed here"></a>ORA-00984: column not allowed here</h3><p>这个问题就是因为插入的字符串没有加单引号，看看代码是否写成了类似于</p><p><code>sql = f&quot;&quot;&quot; insert into classroom values (&#123;name&#125;, &#123;age&#125;,&#123;sex&#125;)&quot;&quot;&quot;</code></p><p>的样子，出现这个原因大概率是因为这样，所以这里还是再强调一遍推荐使用**<a href="#%E4%BD%BF%E7%94%A8%E7%BB%91%E5%AE%9A%E5%8F%98%E9%87%8F-Bind-Variables">绑定变量</a>**的方法进行sql语句编写</p><h3 id="程序执行完后数据并未写入数据库"><a href="#程序执行完后数据并未写入数据库" class="headerlink" title="程序执行完后数据并未写入数据库"></a>程序执行完后数据并未写入数据库</h3><p>目前没有遇到过如此问题，不过记得关闭连接之前先提交事务<code>commit()</code>，很有可能是因为事务忘提交了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cx_Oracle操作Oracle数据库(一):配置篇</title>
      <link href="/2021/08/30/cx_Oracle_1/"/>
      <url>/2021/08/30/cx_Oracle_1/</url>
      
        <content type="html"><![CDATA[<hr><p>&emsp;&emsp;前不久刚找到了第一份实习工作,刚进公司搞不了啥东西,也就熟悉一下环境,于是导师就给了我一份解析excel数据的活干.要求是将远程服务器中的数据拉到本地,并用python将数据进行解析,然后存入Oracle数据库中.网上查了一下,看上去使用最多的就是cx_Oracle这个库了,cx_Oracle配置起来较为复杂,刚开始的时候弄了半天才弄好.<span id="more"></span>  </p><h2 id="cx-Oracle-介绍"><a href="#cx-Oracle-介绍" class="headerlink" title="cx_Oracle 介绍"></a>cx_Oracle 介绍</h2><hr><p>详细信息请参阅<a href="https://cx-oracle.readthedocs.io/en/latest/"><font color="lightblue">cx_Oracle官方文档</font></a></p><hr><p>&emsp;&emsp;cx_Oracle是一个Python扩展模块,支持Python访问Oracle数据库.</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>&emsp;&emsp;该拓展模块大致的结构如下图  </p><img src="/2021/08/30/cx_Oracle_1/cx_Oracle_arch.png" class title="cx_Oracle_arch">  <p>&emsp;&emsp;开发者通过编写python程序来调用cx_Oracle模块,而cx_Oracle在内部动态加载 Oracle 客户端库以访问 Oracle 数据库,连接的数据库可以在本地,也可以在远程服务器.<br>&emsp;&emsp;图中与Oracle数据库真正进行通信连接的是最下方的Oracle client libraries，也就是oracle客户端的一些库，由此可以看出,要想通过cx_Oracle操控Oracle数据库,仅仅安装cx_Oracle这个模块是不够的，必须用到Oracle的客户端.</p><h3 id="instant-client"><a href="#instant-client" class="headerlink" title="instant client"></a>instant client</h3><p>&emsp;&emsp;客户端一般使用<a href="https://www.oracle.com/database/technologies/instant-client/downloads.html"><font color="lightblue">oracle instant client</font></a>,cx_Oracle在进行操作时只需要用到oracle客户端中的一些库,因此选择Basic Light进行下载即可,注意选的时候不要选错了版本，版本选择最新的就好,以Windows.x64为例，选择此项，高版本的向下一般都可以兼容.  </p><img src="/2021/08/30/cx_Oracle_1/download.png" class><p>下载完后解压,之后将文件夹路径添加到系统变量中即可完成oracle client的准备.</p><h2 id="cx-Oracle-安装"><a href="#cx-Oracle-安装" class="headerlink" title="cx_Oracle 安装"></a>cx_Oracle 安装</h2><p><em>注意:文章中使用的版本为 <font color="lightblue"><strong>python3.6+</strong></font></em><br>&emsp;&emsp;由于本人python脚本的编写是在pycharm中进行的,因此直接通过GUI添加了cx_Oracle这个模块,如果是命令行,则可以用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install cx-oracle</span><br></pre></td></tr></table></figure><p>来进行安装.如果安装失败,很有可能是网络原因,可以选择换pip镜像源或者<a href="https://pypi.org/project/cx-Oracle/#files"><font color="lightblue">下载离线包</font></a>来安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#转移到存放下载好的模块的地方</span></span><br><span class="line"><span class="built_in">cd</span> .../modules/</span><br><span class="line">pip3 install cx_Oracle-8.2.1-cp36-cp36m-manylinux1_x86_64.whl</span><br></pre></td></tr></table></figure><h2 id="使用cx-Oracle连接数据库"><a href="#使用cx-Oracle连接数据库" class="headerlink" title="使用cx_Oracle连接数据库"></a>使用cx_Oracle连接数据库</h2><p>安装完cx_Oracle库之后即可开始使用cx_Oracle操作数据库  ，下面是一个最简易的cx_Oracle连接数据库的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cx_Oracle</span><br><span class="line">DB = <span class="string">&#x27;username/password@ip:port/SERVICE_NAME&#x27;</span></span><br><span class="line">conn = cx_Oracle.connect(DB)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sql = <span class="string">&quot;select to_char(sysdate,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) from dual&quot;</span></span><br><span class="line">    <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cur:</span><br><span class="line">        result = cur.execute(sql).fetchall()</span><br><span class="line">    <span class="built_in">print</span>(result[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="comment">#2021-08-31 09:47:16</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><p>如果配置无误，最后数据库会成功返回当前的日期时间.</p><p>如果环境变量中配置过数据库的TNS_ADMIN路径并配置好了tnsnames.ora文件，就可以通过如下方式连接:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tnsnames.ora文件配置示例</span></span><br><span class="line">mydb =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = x.x.x.x)(PORT = 1521))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SERVICE_NAME = orcl)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection = cx_Oracle.connect(user=user, password=userpwd, dsn=<span class="string">&quot;mydb&quot;</span>,</span><br><span class="line">                               encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br></pre></td></tr></table></figure><p>只需要配置用户名和密码即可进行连接。</p><h2 id="附一些常见错误："><a href="#附一些常见错误：" class="headerlink" title="附一些常见错误："></a>附一些常见错误：</h2><h3 id="DPI-1047：这一类报错通常是cx-oracle一些本地的配置的问题"><a href="#DPI-1047：这一类报错通常是cx-oracle一些本地的配置的问题" class="headerlink" title="DPI-1047：这一类报错通常是cx_oracle一些本地的配置的问题"></a>DPI-1047：这一类报错通常是cx_oracle一些本地的配置的问题</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cx_Oracle.DatabaseError: DPI-1047: Cannot locate a 64-bit Oracle Client library: <span class="string">&quot;The specified module could not be found&quot;</span></span><br></pre></td></tr></table></figure><p><strong>原因</strong> </p><ul><li>系统路径中没有添加Oracle的客户端路径  </li><li>系统安装的cx_Oracle版本与Oracle客户端版本不匹配（ x32 | x64 ）</li></ul><p><strong>解决方法</strong>  </p><p>如果路径有误:<br>&emsp;&emsp;添加相应的路径到环境变量中  </p><ul><li>Windows:<br>  PATH中添加…\instantclient_11_2文件夹即可</li><li>Linux:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#永久将该路径存入系统变量中</span></span><br><span class="line">sudo sh -c <span class="string">&quot;echo /opt/oracle/instantclient_21_1 &gt; /etc/ld.so.conf.d/oracle-instantclient.conf&quot;</span>  </span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>如果是版本不匹配，那么就重新下载位数匹配的客户端客户端再次进行尝试.  </li></ul><h3 id="ORA-12514：这一类报错通常是数据库服务方面的问题"><a href="#ORA-12514：这一类报错通常是数据库服务方面的问题" class="headerlink" title="ORA-12514：这一类报错通常是数据库服务方面的问题"></a>ORA-12514：这一类报错通常是数据库服务方面的问题</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cx_Oracle.DatabaseError: ORA-12514: TNS:listener does not currently know of service requested <span class="keyword">in</span> connect descriptor</span><br></pre></td></tr></table></figure><p><strong>原因</strong> </p><ul><li>Oracle连接服务名设置出错  </li></ul><p><strong>解决方法</strong>  </p><ul><li><p>修改Oracle连接的服务名，服务名可以通过oracle命令行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">PARAMETER</span> service_names</span><br><span class="line">NAME                                 TYPE        <span class="keyword">VALUE</span></span><br><span class="line"><span class="comment">------------------------------------ ----------- ------------------------------</span></span><br><span class="line">service_names                        string      orcl</span><br></pre></td></tr></table></figure><p>可以看到这里服务名就是orcl(一般默认服务名即为orcl).修改后应该就可以成功连接了.</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh密钥验证那些事</title>
      <link href="/2021/08/28/SSHkey/"/>
      <url>/2021/08/28/SSHkey/</url>
      
        <content type="html"><![CDATA[<hr><p>&emsp;&emsp;第一次接触到ssh密钥还是我在捣鼓树莓派的时候，当时拿着我的树莓派PI4B在搞项目，做一些IoT之类的小系统.当时需要上传各种驱动和相关代码进行测试，单纯的命令行进行ssh连接肯定会比较麻烦，但又感觉像<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">putty</a>、<a href="https://mobaxterm.mobatek.net/">MobaXterm</a>这类的又不够美观，于是就选择了Vscode来作为IDE，它里面的remote-ssh插件可以很方便的与linux服务器进行ssh连接，只需要配置好.config文件就可以进行连接了.但是有一个问题，每次连树莓派的时候我就都得输一次密码，有时候一不小心关了终端什么的，又得重新开一遍，挺麻烦的，于是就在网上找有没有什么方法可以让vscode记录密码自动登录或者可以避开密码验证什么的，然后我就找到了这个叫做SSH key 的东西.<span id="more"></span>  </p><hr><h2 id="SSH-key简单介绍"><a href="#SSH-key简单介绍" class="headerlink" title="SSH key简单介绍"></a>SSH key简单介绍</h2><p>&emsp;&emsp;通常我们进行SSH远程连接服务器是指定一个用户，然后再输入其密码，由服务器进行验证通过之后即可建立连接.<br>&emsp;&emsp;SSH key的验证方法有一些不同，它会同时产生两个密码(密钥)，其中一个被称作公钥，另一个被称作私钥.公钥，顾名思义，就是可以公开的密钥，交由服务器保管作为加密密钥和凭证，而私钥则是自己需要秘密保管的密钥.<br>&emsp;&emsp;SSH key采用了一种叫做”<a href="https://baike.baidu.com/item/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/1208652?fr=aladdin">非对称加密</a>“的方式进行通信加密  </p><img src="/2021/08/28/SSHkey/wiki.png" class>  <p>Nicobon，<a href="https://commons.wikimedia.org/w/index.php?curid=48484042">CC BY-SA 4.0</a></p><p>其默认算法是<a href="https://baike.baidu.com/item/RSA%E7%AE%97%E6%B3%95/263310?fromtitle=RSA&fromid=210678&fr=aladdin">rsa算法</a>，用户需要与服务器建立连接时，就向服务器发起请求，同时将公钥（<font color="#fdb933">由私钥可以很容易生成公钥，但是由公钥生成私钥以目前的算力来说几乎不可能</font>）捎带上去，服务器将该密钥与留存在自己机器上的公钥相比对，如果有一致的话，就会向请求主机发送一个用该公钥加密的“challenge request”，只有私钥才能解密该“challenge request”并作出相应的回应.<br>&emsp;&emsp;这一系列的过程中，只有公钥在网络上进行了传递，私钥一直保存在了本机，相比于输入密码，密码通过网络传递到服务器再进行验证的过程来说，无疑是更加安全的.</p><h2 id="SSH-key使用"><a href="#SSH-key使用" class="headerlink" title="SSH key使用"></a>SSH key使用</h2><p>&emsp;&emsp;一般在发行版的linux中，系统在第一次初始化的时候都会生成默认的公钥和私钥对，存放路径在/etc/ssh/ 文件夹下：</p><img src="/2021/08/28/SSHkey/sshkey.png" class title="sshkey"><p>里面预置了许多算法，如dsa、rsa、ecdsa等，一般的sshkeys都会使用rsa算法来生成密钥对.要使用该密钥对，可以进行如下操作:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/ssh/ssh_host_rsa_key.pub  ~/.ssh/id_rsa</span><br><span class="line">sudo chmod 600  ~/.ssh/id_rsa</span><br><span class="line"># 如果有特定的端口，请用 scp -P port 指定</span><br><span class="line">scp /etc/ssh/ssh_host_rsa_key   usr@host:~</span><br><span class="line"># 连接到服务器</span><br><span class="line">ssh usr@host</span><br><span class="line">sudo cat ~/ssh_host_rsa_key  &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>*<strong>注意*：id_rsa的权限（包括.ssh目录权限）不能过高，一般600即可，否则会报错</strong></p><img src="/2021/08/28/SSHkey/rsaerror.png" class title="error"><p>&emsp;&emsp;此外，生成ssh-key密钥对还可以采用SSH-keygen的命令，这里也更推荐使用这种方法来使用ssh密钥，该方法可以在该用户目录下生成.ssh文件夹.并在该文件夹下存放密钥，不必担心文件权限的问题.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C  &quot;your comments&quot; </span><br></pre></td></tr></table></figure><p>-t 指代加密方式，方式有[ dsa | ecdsa | ecdsa-sk | ed25519 | ed25519-sk | <strong>rsa</strong> ]默认方式即为rsa<br>-C 则为注释，会显式放在公钥末尾上，可以由此辨别公钥.<br>输入命令之后，系统会让你输入密钥对存放路径，默认放在~/.ssh/ 路径下，确定好历经之后就要求输入密钥的密码（一般直接回车两次跳过即可） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): /root/.ssh/id_rsa</span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /root/ssh/id_rsa</span><br><span class="line">Your public key has been saved in /root/ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>将公钥复制到需要登陆的服务器上的authorized_keys之后，即可使用该ssh密钥对进行ssh密钥方式登录.  </p><h2 id="github-SSH-key添加方式"><a href="#github-SSH-key添加方式" class="headerlink" title="github SSH key添加方式"></a>github SSH key添加方式</h2><p>&emsp;&emsp;早在去年，github就宣布了要取消<a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/">账户密码登录</a>的验证方式，并在今年8月13号正式实施.如今使用账号密码进行push时，github会直接拒绝验证，因此必须采取添加SSH密钥或其他的方式进行登录验证.在成功生成了SSH key密钥对之后，其实需要操作的步骤就很简单了</p><img src="/2021/08/28/SSHkey/addkey.png" class title="addkey">  <p>只需要将自己的id_rsa.pub中的内容复制，粘贴到key框中即可  </p><img src="/2021/08/28/SSHkey/addnew.png" class title="addnew"><p>可采用如下方法测试:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">Hi mrilboom! You&#x27;ve successfully authenticated， but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>之后登录github即可自动使用ssh密钥登录</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ssh </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
