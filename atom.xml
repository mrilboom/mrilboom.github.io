<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mrilboom</title>
  
  <subtitle>welcome to mrilboom&#39;s world</subtitle>
  <link href="https://mrilboom.github.io/atom.xml" rel="self"/>
  
  <link href="https://mrilboom.github.io/"/>
  <updated>2021-09-14T03:07:28.470Z</updated>
  <id>https://mrilboom.github.io/</id>
  
  <author>
    <name>mrilboom</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何优雅地在PyCharm中调试代码</title>
    <link href="https://mrilboom.github.io/2021/09/13/PyCharmDEBUG/"/>
    <id>https://mrilboom.github.io/2021/09/13/PyCharmDEBUG/</id>
    <published>2021-09-13T06:17:55.000Z</published>
    <updated>2021-09-14T03:07:28.470Z</updated>
    
    <content type="html"><![CDATA[<hr><p>最近有个朋友走上了编程的道路,之前劝了他好几回不要入坑,他不听,铁了心要来,于是乎教了他一些PyCharm里面DEBUG的方法,这篇博客也是为他而写的,我尽量从最基础的操作开始讲解,如何一步一步的调试代码,找出代码中的BUG.<span id="more"></span></p><hr><h2 id="一年前的聊天记录"><a href="#一年前的聊天记录" class="headerlink" title="一年前的聊天记录"></a>一年前的聊天记录</h2><p>Comedian</p><p>你怎么把那个笔记打在黑白那个背景上的啊</p><p align="right">Geronimo</p><p align="right">?</p><p>Comedian</p><p>黑白的那个背景</p><p align="right">Geronimo</p><p align="right">什么东西啊？</p><p>Comedian</p><p>你上次给我看过那个</p><p>Comedian</p><img src="/2021/09/13/PyCharmDEBUG/codered.jpg" class><p>Comedian</p><p>像这个</p><p align="right">Geronimo</p><p align="right">这**</p><p align="right">Geronimo</p><p align="right">你是**吗</p><p align="right">Geronimo</p><p align="right">你以为是记笔记的软件呢</p><p>Comedian</p><p>因为记在word里很sb</p><p>Comedian</p><p>全是错误提醒</p><p>Comedian</p><p>还自动大小写</p><p align="right">Geronimo</p><p align="right">没事</p><p align="right">Geronimo</p><p align="right">你记在IDE里更**</p><p align="right">Geronimo</p><p align="right">写一行红一行</p><p><em>而一年后的今天,他竟然做到了：</em></p><img src="/2021/09/13/PyCharmDEBUG/codered2.jpg" class><h2 id="什么叫DEBUG"><a href="#什么叫DEBUG" class="headerlink" title="什么叫DEBUG"></a>什么叫DEBUG</h2><p>&emsp;要说到DEBUG那肯定要知道BUG是什么,BUG英文意为虫子,而计算机中的BUG一词也源自一只小飞虫：1945年9月9日,格蕾丝使用的Mark Ⅱ出现故障格蕾丝使用的Mark Ⅱ出现故障,经过了近一天的检查,格蕾丝找到了故障的原因：继电器中有一只死掉的蛾子（那时的计算机系统用的还都是一个个继电器,机器也异常庞大）,后来,”<a href="https://baike.baidu.com/item/bug/3353935">BUG</a>” 和”<a href="https://baike.baidu.com/item/debug/825293">DEBUG</a>”  这两个本来普普通通的词汇成了计算机领域中特指莫明其妙的“错误”和“排除错误”的专用词汇而流传至今,而格蕾丝·赫柏也因此成了第一个发现“bug”的人.</p><h2 id="如何找到bug"><a href="#如何找到bug" class="headerlink" title="如何找到bug"></a>如何找到bug</h2><p>&emsp;&emsp;找bug有许多方式,这里只介绍PyCharm里的DEBUG的一些办法.</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li><em>python 3.6</em></li><li>PyCharm</li><li>PyCharm中文语言包插件(IDE中安装)</li></ul><p>&emsp;&emsp;我觉得IDE改语言为中文对于python初学者来说挺不错的,就算你英文很好我也建议你改用中文的语言设置.在学习python时没必要把时间浪费在花在理解英文意思上,阅读自己的母语总比阅读外语要来的效率高吧.同时自2020年5月份起,JetBrain已经加入了官方汉化,汉化的总体上的质量不错.</p><p>&emsp;&emsp;但是因为英文是原生语言,其中有些计算机中的名词并没有很统一的中文命名,而且有少数时候翻译会显得很生硬,这种情况确实是难以避免的.</p><h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><p>先来看这一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1196.167</span>,<span class="number">136.667</span>,<span class="number">1933.583</span>,<span class="number">3650.667</span>,<span class="number">255.0833</span>,<span class="number">1392.157</span>,<span class="number">2227.25</span>]</span><br><span class="line">B = [<span class="number">328.8636</span>,<span class="number">549.0152</span>,<span class="number">127.3485</span>,<span class="number">1597.576</span>,<span class="number">1198.712</span>,<span class="number">10437.95</span>,<span class="number">22699.32</span>]</span><br><span class="line">C = [<span class="number">325</span>, <span class="number">1831.5971209</span>,<span class="number">725.0694</span>,<span class="number">565.4167</span>]</span><br><span class="line">X = []</span><br><span class="line">Y = []</span><br><span class="line">Z = []</span><br><span class="line">weight = <span class="number">1e9</span></span><br><span class="line">weight_min = weight</span><br><span class="line">resA = [[]]</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> A:</span><br><span class="line">    resA += [i + [num] <span class="keyword">for</span> i <span class="keyword">in</span> resA]</span><br><span class="line"><span class="keyword">for</span> ls <span class="keyword">in</span> resA:</span><br><span class="line">    X.append(<span class="built_in">sum</span>(ls))</span><br><span class="line">A = X[<span class="number">1</span>:]</span><br><span class="line">result = []</span><br><span class="line">resB = [[]]</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> B:</span><br><span class="line">    resB += [i + [num] <span class="keyword">for</span> i <span class="keyword">in</span> resB]</span><br><span class="line"><span class="keyword">for</span> ls <span class="keyword">in</span> resB:</span><br><span class="line">    Y.append(<span class="built_in">sum</span>(ls))</span><br><span class="line">B = Y[<span class="number">1</span>:]</span><br><span class="line">resC = [[]]</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> C:</span><br><span class="line">    resC += [i + [num] <span class="keyword">for</span> i <span class="keyword">in</span> resC]</span><br><span class="line"><span class="keyword">for</span> ls <span class="keyword">in</span> resC:</span><br><span class="line">    Z.append(<span class="built_in">sum</span>(ls))</span><br><span class="line">C = Z[<span class="number">1</span>:]</span><br><span class="line">D = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> B:</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> C:</span><br><span class="line">            <span class="keyword">if</span> a+b+c &gt;= <span class="number">56400</span>:</span><br><span class="line">                weight = <span class="number">1.2</span>*a*<span class="number">0.6</span> + <span class="number">1.1</span>*b*<span class="number">0.66</span> + c*<span class="number">0.72</span></span><br><span class="line">                <span class="keyword">if</span> weight&lt;weight_min:</span><br><span class="line">                    weight_min = weight</span><br><span class="line">                    result = [a,b,c]</span><br><span class="line">                    D[weight]=result</span><br><span class="line"><span class="built_in">print</span>(weight_min)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">out = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(out):</span><br><span class="line">    item = D.popitem()</span><br><span class="line">    <span class="built_in">print</span>(item[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)):</span><br><span class="line">        <span class="keyword">if</span> item[<span class="number">1</span>][<span class="number">0</span>] == A[i]:</span><br><span class="line">            <span class="built_in">print</span>(resA[i + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(B)):</span><br><span class="line">        <span class="keyword">if</span> item[<span class="number">1</span>][<span class="number">1</span>] == B[i]:</span><br><span class="line">            <span class="built_in">print</span>(resB[i + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(C)):</span><br><span class="line">        <span class="keyword">if</span> item[<span class="number">1</span>][<span class="number">2</span>] == C[i]:</span><br><span class="line">            <span class="built_in">print</span>(resC[i + <span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;**********&quot;</span>)</span><br></pre></td></tr></table></figure><p>这一段代码执行后报错了,PyCharm中的控制台输出如下:</p><img src="/2021/09/13/PyCharmDEBUG/debug1.jpg" class><p>它提示<code>popitem(): dictionary is empty</code>从字面上来看是字典为空出现的问题,那么哪里出了问题呢？前面说到在help.py这个文件中的第45行出了错,那我们就找找第45行中的错误,如果有经验的人一眼就可以看出问题所在了,但是对于新手来说可能会有一点困难,因此我们可以通过“打断点”的方式对程序进行调试(DEBUG).</p><p>&emsp;&emsp;打断点是指在程序中标记一个断点,在执行调试时,程序会在将要执行到断点所在那行的代码时停下,此时我们可以观察程序所保存的变量来确定程序出现BUG的原因.</p><p>&emsp;&emsp;以这个BUG为例,程序报错在第45行产生,那就在第45行打上断点：</p><img src="/2021/09/13/PyCharmDEBUG/breakpoint.gif" class><p><em>点击此处即可添加断点,再次点击即可取消断点</em></p><h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>打好断点后即可开始调试,可以通过右键PyCharm代码编辑栏选择“调试”来进行调试</p><img src="/2021/09/13/PyCharmDEBUG/debug.gif" class><p>等待程序执行到目标位置时,程序就会暂停并统计当前变量信息.</p><p>红框上的几个图标分别为：</p><p>步过：若函数A内存在子函数a时,不会进入子函数a内执行单步调试,而是把子函数a当作一个整体,一步执行.</p><p>步入：若函数A内存在子函数a时,会进入子函数a内执行单步调试.</p><p>单步执行我的代码：执行下一行但忽略libraries（导入库的语句）</p><p>步出：当目前执行在子函数a中时,选择该调试操作可以直接跳出子函数a,而不用继续执行子函数a中的剩余代码.并返回上一层函数.</p><p>运行到光标处：运行到鼠标光标所在的地方,在光标与当前断点中还存在断点或光标位置不可达（程序已经执行过的部分或if的另一个分支等情况）,则执行到下一个断点.</p><p>执行到这里,我们可以观察当前存在的变量,之前报错发现是”dictionary is empty”的错误,我们之前定义了字典为D,那就找D的变量,如果一时间找不到,则可以点击加号输入要监视的变量</p><img src="/2021/09/13/PyCharmDEBUG/addwatch.jpg" class><h3 id="找到问题根源"><a href="#找到问题根源" class="headerlink" title="找到问题根源"></a>找到问题根源</h3><p>找到D之后发现缺失D这个字典里面是空的,为什么是空的？那就找哪里修改了D,可以看到第37行我们对D进行了添加条目的操作,那么尝试在37行打断点,尝试进行调试：</p><img src="/2021/09/13/PyCharmDEBUG/ops.gif" class><p>此时发现我们的断点被直接跳过了,程序似乎”执行到”37行时并没有停下来列出消息,此时细想一下,程序有可能并没有执行到这一行,有可能是for一开始就跳出循环了,也有可能是if的条件为false了,所以直接跳过了这个地方,这时候我们又得判断一下是哪条语句导致的问题,那就在整个大循环开始的时候打上一个端点,然后一步步单步执行看程序的执行路径</p><img src="/2021/09/13/PyCharmDEBUG/step.gif" class><p>可以看到程序在总是在执行到<code> if a+b+c &gt;= 56400:</code>这一行之后就直接进入了下一步循环,并没有步入,这时候我们就可以提出一个合理的猜测：是否<code>a+b+c &gt;= 56400</code>永远为假呢？结合自己写的代码可以简易推出确实如此,写代码的时候有可能是数据录入错误,或者是条件表达式写错了.</p><h3 id="评估表达式工具"><a href="#评估表达式工具" class="headerlink" title="评估表达式工具"></a>评估表达式工具</h3><img src="/2021/09/13/PyCharmDEBUG/calc.jpg" class><p>可以看到在各种调试按钮边上还有一个不起眼的计算器样子的图案,那就是评估表达式工具,它可以在调试过程中执行自定义的代码行（段）,比如想要在下面这段代码中判断if条件表达式的信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a=1420,b=220,c=300</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (a+b+c &lt;= <span class="number">2000</span>) &amp; (c &lt; <span class="number">200</span>):</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以通过计算条件表达式来进行判断</p><img src="/2021/09/13/PyCharmDEBUG/eval.gif" class><p>这个表达式其实就是额外执行了一段代码,如果在里面对变量进行赋值操作的话,也会生效</p><img src="/2021/09/13/PyCharmDEBUG/change.gif" class><p>因此注意一些函数,比如pop（）函数,它可以看到栈中最后的一个元素,在执行时该元素也在栈中被剔除了,因此不要用到这些会影响到变量的函数.</p><img src="/2021/09/13/PyCharmDEBUG/pop.gif" class><h3 id="修改变量"><a href="#修改变量" class="headerlink" title="修改变量"></a>修改变量</h3><p>有时候我们会有修改程序运行过程中变量的需求,我们此时就可以通过上面评估表达式进行变量赋值操作来修改变量,同时也可以通过直接右键变量设置值来进行修改</p><img src="/2021/09/13/PyCharmDEBUG/change2.gif" class><h3 id="CTRL-左键点击"><a href="#CTRL-左键点击" class="headerlink" title="CTRL + 左键点击"></a>CTRL + 左键点击</h3><p>有时候代码太过冗长,不容易找到某个变量的定义和修改所在的位置,我们即可通过按住<code>ctrl</code>然后鼠标单击变量名进行查找</p><p>该功能在调试外也适用,如果点击的是一些导入库或者是python的一些内置函数或类型,那么PyCharm也会转到相应的定义页面,一般来说这些函数或者类下面都会有</p><img src="/2021/09/13/PyCharmDEBUG/exl.gif" class><h2 id="最后说一说"><a href="#最后说一说" class="headerlink" title="最后说一说"></a>最后说一说</h2><p>&emsp;&emsp;无论如何,要找到BUG,就得看懂程序,理清其中的逻辑,逻辑都没有弄清楚就想找到并解决问题,怎么可能呢?用各种外部库函数的时候也要多去看看文档,看看源码,可能就像当年格蕾丝一样,在上百行上千行的代码中找了一整天的bug,就是由一只小小的“飞蛾”引起的.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_33472146/article/details/90606359">醒了的追梦人|Pycharm Debug调试</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;最近有个朋友走上了编程的道路,之前劝了他好几回不要入坑,他不听,铁了心要来,于是乎教了他一些PyCharm里面DEBUG的方法,这篇博客也是为他而写的,我尽量从最基础的操作开始讲解,如何一步一步的调试代码,找出代码中的BUG.&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://mrilboom.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>cron计划任务</title>
    <link href="https://mrilboom.github.io/2021/09/09/cron/"/>
    <id>https://mrilboom.github.io/2021/09/09/cron/</id>
    <published>2021-09-09T02:06:03.000Z</published>
    <updated>2021-09-10T09:03:11.792Z</updated>
    
    <content type="html"><![CDATA[<hr><p>&emsp;&emsp;之前在做数据解析自动化导入的时候,因为前端的调度系统出现了问题,导致无法连接上远程的shell,因此只能在本地进行任务的自动导入,用到的就是 cron 这个工具.<span id="more"></span></p><hr><h2 id="cron-介绍"><a href="#cron-介绍" class="headerlink" title="cron 介绍"></a>cron 介绍</h2><p>在 Linux 系统中 crontab 是用来定期执行程序的命令,当安装完成操作系统之后,默认便会启动此任务调度命令. cron每分钟会定期检查是否有要执行的工作,如果有要执行的工作便会自动执行该工作.</p><h3 id="cron-和-crontab-的区别"><a href="#cron-和-crontab-的区别" class="headerlink" title="cron 和 crontab 的区别"></a>cron 和 crontab 的区别</h3><p>cron 是 Linux 进行定期执行程序的一个工具,它提供给用户一个条 crontab 命令来进行调度使用,而 crontab 则是 cron 提供给用户进行计划任务管理的一条命令.</p><h2 id="使用-cron"><a href="#使用-cron" class="headerlink" title="使用 cron"></a>使用 cron</h2><h3 id="cron-安装"><a href="#cron-安装" class="headerlink" title="cron 安装"></a>cron 安装</h3><p>&emsp;&emsp;一般 Linux 系统中都会默认安装并自动启用 cron,可输入 <code>cron</code>命令进行查看,如果没有安装,则可以进行手动安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">yum install vixie-cron</span><br><span class="line">yum install crontabs</span><br><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">apt-get install cron</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">service cron start</span><br><span class="line"><span class="comment"># 设置自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> cron</span><br></pre></td></tr></table></figure><h3 id="cron-使用"><a href="#cron-使用" class="headerlink" title="cron 使用"></a>cron 使用</h3><p>&emsp;&emsp;启动了 cron 服务之后,就可以通过 crontab 命令来进行管理使用,cron通过读取 crontab 配置表来进行计划的执行,对于用户而言,配置表在<code>/var/spool/cron/crontabs/username</code>中,要修改表只需要通过执行<code>crontab -e</code>就可对里面的数据进行修改.而对于系统而言,计划任务的配置在<code>/etc/crontab</code>中,直接通过修改该文件即可进行全局配置.</p><p>&emsp;&emsp;cron 基本的配置如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br><span class="line">t1 t2 t3 t4 t5 (user-name) <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>其中,command 即为打算计划执行的命令,t1、t2、t3、t4、t5 分别为执行日期分钟、小时、日、月和星期的设置,以这些数据即可具体到一年中的每一天具体的某时某分的一个时间点.其中:</p><ul><li><code>*</code>代表所有时间</li><li><code>-</code>代表时间段区间</li><li><code>,</code>代表单独时间</li><li><code>/</code>代表每隔多少时间</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 8 *  *  1-5  wall Good morning, programmer!</span><br></pre></td></tr></table></figure><p>比如上面的这条命令就可以在每周工作日早上8点钟向所有登录终端的用户发送一条消息.</p><p>如果想设置工作日,从8点起到18点,每隔2小时发送一条消息,可以改成:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 8-18/2 *  *  1-5  wall Hello, programmer!</span><br></pre></td></tr></table></figure><p>这些参数中,有两个比较特别: t3 和 t5 ,比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 8 9  *  5  wall Good morning, programmer!</span><br></pre></td></tr></table></figure><p>2021年9月9日是周四,这条命令会在每月的9号和每周的周五执行,具体把时间分组的话可以分为G1:t1,t2（几时几分）,G2:t3,t4（几月几日）,G3:t5（周几）,最后的执行时间就是R1:(G1,G2)与R2:(G1,G3)取并集(∪).而每个G、R之内的时间都是取交集(∩)的.</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>&emsp;&emsp;在网上找到了一个可以在线进行 cron 表达式测试的网站:<a href="https://tool.lu/crontab/">crontab 执行时间计算</a>,如果对于时间设置不熟悉的可以在这里多尝试一下.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.runoob.com/linux/linux-comm-crontab.html">菜鸟教程 | Linux crontab 命令</a></li><li><a href="https://www.cnblogs.com/intval/p/5763929.html">再見理想 - 博客园</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;之前在做数据解析自动化导入的时候,因为前端的调度系统出现了问题,导致无法连接上远程的shell,因此只能在本地进行任务的自动导入,用到的就是 cron 这个工具.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://mrilboom.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>cx_Oracle操作Oracle数据库(二):代码篇</title>
    <link href="https://mrilboom.github.io/2021/08/31/cx-Oracle-2/"/>
    <id>https://mrilboom.github.io/2021/08/31/cx-Oracle-2/</id>
    <published>2021-08-31T08:02:09.000Z</published>
    <updated>2021-09-10T09:02:59.688Z</updated>
    
    <content type="html"><![CDATA[<hr><p>&emsp;&emsp;<a href="/2021/08/30/cx_Oracle_1/" title="上一篇">上一篇</a>讲了cx_Oracle的安装以及相关的环境配置,本篇就来讲讲cx_Oracle这个模块的具体使用方法.<span id="more"></span></p><hr><p>&emsp;&emsp;<em>本文只介绍基本的一些数据库最基本的操作方法,不涉及到连结池、存储过程等操作</em></p><hr><p>详细信息请参阅<a href="https://cx-oracle.readthedocs.io/en/latest/">cx_Oracle官方文档</a></p><hr><h2 id="cx-Oracle一些对象的介绍"><a href="#cx-Oracle一些对象的介绍" class="headerlink" title="cx_Oracle一些对象的介绍"></a>cx_Oracle一些对象的介绍</h2><h3 id="在成功连接数据库之后"><a href="#在成功连接数据库之后" class="headerlink" title="在成功连接数据库之后"></a>在成功连接数据库之后</h3><p>在连接上数据库之后,cx_Oracle会返回一个<a href="https://cx-oracle.readthedocs.io/en/latest/api_manual/connection.html#connection-object">Connection对象</a>,该对象用的比较多的就是<code>Connection.cursor()</code>和<code>Connection.close()</code>了,前者是用来返回一个新的<em>cursor</em> 对象,我们进行的CRUD等大部分的操作都要用到<em>cursor</em> 对象来进行操作.后者则是关闭连接的操作,每次执行完程序后,都需要将连接关闭.</p><h3 id="开始前的几个小建议"><a href="#开始前的几个小建议" class="headerlink" title="开始前的几个小建议"></a>开始前的几个小建议</h3><ul><li><p>建立完数据库连接之后,尽量使用try——finally语句,避免因为程序出错而导致数据库连接未被正常关闭的现象的出现.    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conn = cx_Oracle.connect(DB)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    ...<span class="comment"># your codes</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><p>这样一来,即使程序运行出错,最终也会关闭连接.</p></li><li><p>使用<em>cursor</em>游标时也要注意,需要手动关闭游标,不过为了方便,一般有需要到时可以使用with…as…的方法来进行调用,下面的这段代码能够确保一旦代码块完成,游标就会被回收关闭.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cur:</span><br><span class="line">    ...<span class="comment"># cursor operation</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用cx-Oracle"><a href="#使用cx-Oracle" class="headerlink" title="使用cx_Oracle"></a>使用cx_Oracle</h2><h3 id="使用使用cx-Oracle进行查询"><a href="#使用使用cx-Oracle进行查询" class="headerlink" title="使用使用cx_Oracle进行查询"></a>使用使用cx_Oracle进行查询</h3><p>执行完对应sql语句后,游标可以通过按行进行迭代来获取所要查询的数据.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cur:</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cur.execute(sql):</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure><p>同时也可以通过游标对象的fetch()方法来获取数据:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cur:</span><br><span class="line">cur = cur.execute(sql)</span><br><span class="line">result = cur.fetchone()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result))</span><br><span class="line"><span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法首先通过游标<code>cursor.execute()</code>执行sql语句,之后通过<em>cursor</em> 的fetch方法来获取结果,通过打印输出可以看出执行语句获取的结果是以tuple元组的方式返回的,取到数据后就可以进行其他的操作了,而cur也随着代码执行结束自动销毁了.</p><p>&emsp;&emsp;除了用<code>cursor.fetchone()</code>方法之外,还可以用<code>cursor.fetchall()``cursor.fetchmany(num_rows)</code>方法来获取对应行数的数据.</p><p>&emsp;&emsp;如果返回的数据不止一条,数据则会以列表的方式返回,列表中的每一条数据都是一个元组,每个元组表示查询到的一行数据,如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">&quot;LiMing&quot;</span>,<span class="number">12</span>,<span class="number">1</span>),(<span class="string">&quot;LiHu&quot;</span>,<span class="number">13</span>,<span class="number">1</span>),(<span class="string">&quot;XiaoHong&quot;</span>,<span class="number">12</span>,<span class="number">0</span>),(<span class="string">&quot;XiaoHui&quot;</span>,<span class="number">12</span>,<span class="number">0</span>)]</span><br></pre></td></tr></table></figure><p>通过上述方法就能获取到我们执行数据库操作后查询到的结果了.</p><h3 id="使用cx-Oracle进行其他操作（DML、DDL、DCL）"><a href="#使用cx-Oracle进行其他操作（DML、DDL、DCL）" class="headerlink" title="使用cx_Oracle进行其他操作（DML、DDL、DCL）"></a>使用cx_Oracle进行其他操作（DML、DDL、DCL）</h3><p>&emsp;&emsp;进行其他操作一般不需要处理返回结果集,用到的执行函数也是<code>execute()</code>,因此直接编写sql语句再调用execute()方法执行即可.</p><p>&emsp;&emsp;但是有一点需要特别注意,当<code>cur.execute()</code>执行一条 SQL 语句的同时会启动或继续一个事务.默认情况下,cx_Oracle 不会将此事务提交到数据库.方法<code>conn.commit()</code>和<code>conn.rollback()</code>方法可用于显式提交或回滚事务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cursor.execute(<span class="string">&quot;insert ... into ... values ...)</span></span><br><span class="line"><span class="string">connection.commit()</span></span><br></pre></td></tr></table></figure><p>数据库连接conn关闭时,任何<font color="#fdb933">未被提交的事务</font>都会被回滚.</p><h2 id="使用绑定变量-Bind-Variables"><a href="#使用绑定变量-Bind-Variables" class="headerlink" title="使用绑定变量(Bind Variables)"></a>使用绑定变量(Bind Variables)</h2><p>&emsp;&emsp;因为工作中需要对数据进行批量写入,我就进行了python中字符串format的用法对sql语句进行修改:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">insert into classroom values (&#x27;<span class="subst">&#123;name&#125;</span>&#x27;, <span class="subst">&#123;age&#125;</span>,<span class="subst">&#123;sex&#125;</span>)&quot;&quot;&quot;</span></span><br><span class="line">cursor.execute(sql)</span><br></pre></td></tr></table></figure><p>执行也没有问题,但是在我一次查看文档时发现了一段话  </p><p><strong><em>Never concatenate or interpolate user data into SQL statements:</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">did = <span class="number">280</span></span><br><span class="line">dnm = <span class="string">&quot;Facility&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># !! Never do this !!</span></span><br><span class="line">sql = <span class="string">f&quot;&quot;&quot;insert into departments (department_id, department_name)</span></span><br><span class="line"><span class="string">          values (<span class="subst">&#123;did&#125;</span>, &#x27;<span class="subst">&#123;dnm&#125;</span>&#x27;)&quot;&quot;&quot;</span></span><br><span class="line">cursor.execute(sql)</span><br></pre></td></tr></table></figure><p>文档中说到千万不要直接用格式化字符串的方式提交sql命令,理由很简单,因为这样会存在sql注入的问题,把整句sql的语句交给用户来定义肯定是不理性的,之后看了一下文档,解决方法并不复杂,cx_Oracle提供了一个预编译传参的手段,将sql语句的命令预先编译,之后再将参数传入,以此来避免恶意的sql注入问题,我们可以通过<code>cur.execute(sql,bind_params)</code>这条命令来代替之前不安全的方法,bind_params是一个参数列表,比如之前的插入语句就可以修改为这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">insert into classroom values (:name, :age,:sex)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">bind_params = [<span class="string">&quot;XiaoSe&quot;</span>,<span class="number">8</span>,<span class="number">1</span>]</span><br><span class="line">cur.execute(sql,bind_params)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;绑定变量方式可以按照位置、名称、类型等绑定,详细内容参阅<a href="https://cx-oracle.readthedocs.io/en/latest/user_guide/bind.html#using-bind-variables">Using Bind Variables</a>.</p><h2 id="数据批处理"><a href="#数据批处理" class="headerlink" title="数据批处理"></a>数据批处理</h2><p>cx_Oracle为提供了数据批量写入或更新的功能,使得sql语句只用编译一次即可,每次只需更改变量即可,适用于大批量的数据写入或更新的情况.下表将用于示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> CLASSROOM</span><br><span class="line">(</span><br><span class="line">    NAME VARCHAR2(<span class="number">10</span>),</span><br><span class="line">    AGE  NUMBER(<span class="number">4</span>),</span><br><span class="line">    SEX  NUMBER(<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将下面6条数据数据一次性插入到数据库中,代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data = [</span><br><span class="line">    [<span class="string">&#x27;XiaoMing&#x27;</span>,<span class="number">13</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoHong&#x27;</span>,<span class="number">12</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoHui&#x27;</span>,<span class="number">13</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoMei&#x27;</span>,<span class="number">13</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="string">&#x27;LiBai&#x27;</span>,<span class="number">14</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoSe&#x27;</span>,<span class="number">13</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">cursor.executemany(<span class="string">&quot;insert into CLASSROOM values (:1, :2, :3)&quot;</span>, data)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该方法<code>executemany()</code>一次就可以将这批数据写入数据库,避免了5次往返写入,在大批量的数据上效果显著.</p><h3 id="使用批处理时需要注意的一个问题"><a href="#使用批处理时需要注意的一个问题" class="headerlink" title="使用批处理时需要注意的一个问题"></a>使用批处理时需要注意的一个问题</h3><p>&emsp;&emsp;在我做解析excel文件时,想要进一步提高数据库写入速度,我就想用<code>executemany()</code>的批处理来优化,将读取到的每一行以<code>append()</code>的方式放入一个列表中,然后最终通过<code>executemany()</code>来一步完成,但是中间却报错了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: expecting number</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一看,显然是数据格式不对了,但是之前用<code>execute()</code>执行的时候从来没有出错,在仔细分析后,我找到了造成问题的原因,下图是我之前读取数据的excel原表（数据已做更改）</p><img src="/2021/08/31/cx-Oracle-2/excel.png" class><p>&emsp;&emsp;其中中间的几行数据并没有信息,在excel读取数据的时候会把空格读取成<code>&quot;&quot;</code><br>&emsp;&emsp;还是以之前的<em>CLASSROOM</em> 表为例,excel表如下：</p><img src="/2021/08/31/cx-Oracle-2/classroom.png" class><p>&emsp;&emsp;python从excel中读取到的数据如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = [</span><br><span class="line">    [<span class="string">&#x27;XiaoMing&#x27;</span>,<span class="number">13.0</span>,<span class="number">1.0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoHong&#x27;</span>,<span class="number">12.0</span>,<span class="number">0.0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoHui&#x27;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0.0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoMei&#x27;</span>,<span class="number">13.0</span>,<span class="number">0.0</span>],</span><br><span class="line">    [<span class="string">&#x27;LiBai&#x27;</span>,<span class="number">14.0</span>,<span class="number">1.0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoSe&#x27;</span>,<span class="number">13.0</span>,<span class="number">1.0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到第4行中<code>XiaoHui</code>她的年龄数据因为缺失变成了<code>&quot;&quot;</code>,与其它的数字类型不同,因此才造成的错误.而后我又尝试将插入的数据改成:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = [</span><br><span class="line">    [<span class="string">&#x27;XiaoMing&#x27;</span>,<span class="string">&quot;&quot;</span>,<span class="number">1.0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoHong&#x27;</span>,<span class="number">12.0</span>,<span class="number">0.0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoHui&#x27;</span>,<span class="number">13.0</span>,<span class="number">0.0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoMei&#x27;</span>,<span class="number">13.0</span>,<span class="number">0.0</span>],</span><br><span class="line">    [<span class="string">&#x27;LiBai&#x27;</span>,<span class="number">14.0</span>,<span class="number">1.0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoSe&#x27;</span>,<span class="number">13.0</span>,<span class="number">1.0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使得第一行数据缺失,而后报错内容为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: expecting string or bytes object</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此,我也算是知道了这个报错的出现以及之前按条插入数据时没有出现错误的原因了</p><p>&emsp;&emsp;在执行<code>execute()</code>命令时,程序会自动按照输入的数据来编译出一条sql命令以适应数据库的表,之前每一次执行都会单独编译一条sql语句,例如输入了<code> [&#39;XiaoHong&#39;,12.0,0.0],</code>这一行数据,程序就会将对应的<code>string</code>,<code>float</code>,<code>float</code>转化成数据库中的所需求的<code>string</code>,<code>int</code>,<code>int</code>这样的格式,在下一轮迭代中,程序读取到了<code>string</code>,<code>string</code>,<code>float</code>,那么又会产生一个从<code>string</code>,<code>string</code>,<code>float</code>到<code>string</code>,<code>int</code>,<code>int</code>这样的映射以支持不同数据类型的输入.</p><p>&emsp;&emsp;然而在执行<code>executemany()</code>命令时,sql命令<strong>只会编译一次</strong>,所以它只能支持一组数据关系映射,它会读取列表中的第一组元素产生数据映射,所以在数据为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = [</span><br><span class="line">    [<span class="string">&#x27;XiaoMing&#x27;</span>,<span class="string">&quot;&quot;</span>,<span class="number">1.0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoHong&#x27;</span>,<span class="number">12.0</span>,<span class="number">0.0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoHui&#x27;</span>,<span class="number">13.0</span>,<span class="number">0.0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoMei&#x27;</span>,<span class="number">13.0</span>,<span class="number">0.0</span>],</span><br><span class="line">    [<span class="string">&#x27;LiBai&#x27;</span>,<span class="number">14.0</span>,<span class="number">1.0</span>],</span><br><span class="line">    [<span class="string">&#x27;XiaoSe&#x27;</span>,<span class="number">13.0</span>,<span class="number">1.0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>的时候,它就会要求其中输入的<code>age</code>栏都是<code>string</code>类型,当遇到<code>&#39;XiaoHong&#39;</code>的<code>12.0</code>时,便会出错退出.</p><p>&emsp;&emsp;知道了出错的原因那就好办了,只需要在读取excel表数据时将数据强转为对应于数据库表的类型就可以了,之后就可以用<code>executemany()</code>的方法进行处理数据了.</p><h2 id="使用过程中可能会遇到的一些错误"><a href="#使用过程中可能会遇到的一些错误" class="headerlink" title="使用过程中可能会遇到的一些错误"></a>使用过程中可能会遇到的一些错误</h2><h3 id="ORA-00911-invalid-character"><a href="#ORA-00911-invalid-character" class="headerlink" title="ORA-00911: invalid character"></a>ORA-00911: invalid character</h3><p>出现这个问题很有可能是sql句末出现了分号<code>;</code>,在通过cx_Oracle对数据库进行操作时,所有的sql语句都不需要加最后的分号,去掉分号再尝试一遍即可.</p><h3 id="ORA-00984-column-not-allowed-here"><a href="#ORA-00984-column-not-allowed-here" class="headerlink" title="ORA-00984: column not allowed here"></a>ORA-00984: column not allowed here</h3><p>这个问题就是因为插入的字符串没有加单引号,看看代码是否写成了类似于</p><p><code>sql = f&quot;&quot;&quot; insert into classroom values (&#123;name&#125;, &#123;age&#125;,&#123;sex&#125;)&quot;&quot;&quot;</code></p><p>的样子,出现这个原因大概率是因为使用了格式化字符串的方法来编写sql语句,所以这里还是再强调一遍推荐使用**<a href="#%E4%BD%BF%E7%94%A8%E7%BB%91%E5%AE%9A%E5%8F%98%E9%87%8F-Bind-Variables">绑定变量</a>**的方法进行sql语句编写</p><h3 id="程序执行完后数据并未写入数据库"><a href="#程序执行完后数据并未写入数据库" class="headerlink" title="程序执行完后数据并未写入数据库"></a>程序执行完后数据并未写入数据库</h3><p>目前没有遇到过如此问题,不过记得关闭连接之前先提交事务<code>commit()</code>,该问题很有可能是因为事务忘提交而导致的事务回滚造成的.</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href=&quot;/2021/08/30/cx_Oracle_1/&quot; title=&quot;上一篇&quot;&gt;上一篇&lt;/a&gt;讲了cx_Oracle的安装以及相关的环境配置,本篇就来讲讲cx_Oracle这个模块的具体使用方法.&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://mrilboom.github.io/tags/python/"/>
    
    <category term="Oracle" scheme="https://mrilboom.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>cx_Oracle操作Oracle数据库(一):配置篇</title>
    <link href="https://mrilboom.github.io/2021/08/30/cx_Oracle_1/"/>
    <id>https://mrilboom.github.io/2021/08/30/cx_Oracle_1/</id>
    <published>2021-08-30T02:46:51.000Z</published>
    <updated>2021-09-10T09:02:51.868Z</updated>
    
    <content type="html"><![CDATA[<hr><p>&emsp;&emsp;前不久刚找到了第一份实习工作,刚进公司搞不了啥东西,也就熟悉一下环境,于是导师就给了我一份解析excel数据的活干.要求是将远程服务器中的数据拉到本地,并用python将数据进行解析,然后存入Oracle数据库中.网上查了一下,看上去使用最多的就是cx_Oracle这个库了,cx_Oracle配置起来较为复杂,刚开始的时候弄了半天才弄好.<span id="more"></span>  </p><hr><h2 id="cx-Oracle-介绍"><a href="#cx-Oracle-介绍" class="headerlink" title="cx_Oracle 介绍"></a>cx_Oracle 介绍</h2><hr><p>详细信息请参阅<a href="https://cx-oracle.readthedocs.io/en/latest/">cx_Oracle官方文档</a></p><hr><p>&emsp;&emsp;cx_Oracle是一个Python扩展模块,支持Python访问Oracle数据库.</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>&emsp;&emsp;该拓展模块大致的结构如下图  </p><img src="/2021/08/30/cx_Oracle_1/cx_Oracle_arch.png" class title="cx_Oracle_arch">  <p>&emsp;&emsp;开发者通过编写python程序来调用cx_Oracle模块,而cx_Oracle在内部动态加载 Oracle 客户端库以访问 Oracle 数据库,连接的数据库可以在本地,也可以在远程服务器.<br>&emsp;&emsp;图中与Oracle数据库真正进行通信连接的是最下方的Oracle client libraries，也就是oracle客户端的一些库，由此可以看出,要想通过cx_Oracle操控Oracle数据库,仅仅安装cx_Oracle这个模块是不够的，必须用到Oracle的客户端.</p><h3 id="instant-client"><a href="#instant-client" class="headerlink" title="instant client"></a>instant client</h3><p>&emsp;&emsp;客户端一般使用<a href="https://www.oracle.com/database/technologies/instant-client/downloads.html">oracle instant client</a>,cx_Oracle在进行操作时只需要用到oracle客户端中的一些库,因此选择Basic Light进行下载即可,注意选的时候不要选错了版本，版本选择最新的就好,以Windows.x64为例，选择此项，高版本的向下一般都可以兼容.  </p><img src="/2021/08/30/cx_Oracle_1/download.png" class><p>下载完后解压,之后将文件夹路径添加到系统变量中即可完成oracle client的准备.</p><h2 id="cx-Oracle-安装"><a href="#cx-Oracle-安装" class="headerlink" title="cx_Oracle 安装"></a>cx_Oracle 安装</h2><p><em>注意:文章中使用的版本为 <strong>python3.6+</strong></em><br>&emsp;&emsp;由于本人python脚本的编写是在pycharm中进行的,因此直接通过GUI添加了cx_Oracle这个模块,如果是命令行,则可以用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install cx-oracle</span><br></pre></td></tr></table></figure><p>来进行安装.如果安装失败,很有可能是网络原因,可以选择换pip镜像源或者<a href="https://pypi.org/project/cx-Oracle/#files">下载离线包</a>来安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#转移到存放下载好的模块的地方</span></span><br><span class="line"><span class="built_in">cd</span> .../modules/</span><br><span class="line">pip3 install cx_Oracle-8.2.1-cp36-cp36m-manylinux1_x86_64.whl</span><br></pre></td></tr></table></figure><h2 id="使用cx-Oracle连接数据库"><a href="#使用cx-Oracle连接数据库" class="headerlink" title="使用cx_Oracle连接数据库"></a>使用cx_Oracle连接数据库</h2><p>安装完cx_Oracle库之后即可开始使用cx_Oracle操作数据库  ，下面是一个最简易的cx_Oracle连接数据库的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cx_Oracle</span><br><span class="line">DB = <span class="string">&#x27;username/password@ip:port/SERVICE_NAME&#x27;</span></span><br><span class="line">conn = cx_Oracle.connect(DB)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sql = <span class="string">&quot;select to_char(sysdate,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) from dual&quot;</span></span><br><span class="line">    <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cur:</span><br><span class="line">        result = cur.execute(sql).fetchall()</span><br><span class="line">    <span class="built_in">print</span>(result[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="comment">#2021-08-31 09:47:16</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><p>如果配置无误，最后数据库会成功返回当前的日期时间.</p><p>如果环境变量中配置过数据库的TNS_ADMIN路径并配置好了tnsnames.ora文件，就可以通过如下方式连接:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tnsnames.ora文件配置示例</span></span><br><span class="line">mydb =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = x.x.x.x)(PORT = 1521))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SERVICE_NAME = orcl)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection = cx_Oracle.connect(user=user, password=userpwd, dsn=<span class="string">&quot;mydb&quot;</span>,</span><br><span class="line">                               encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br></pre></td></tr></table></figure><p>只需要配置用户名和密码即可进行连接。</p><h2 id="附一些常见错误："><a href="#附一些常见错误：" class="headerlink" title="附一些常见错误："></a>附一些常见错误：</h2><h3 id="DPI-1047：这一类报错通常是cx-oracle一些本地的配置的问题"><a href="#DPI-1047：这一类报错通常是cx-oracle一些本地的配置的问题" class="headerlink" title="DPI-1047：这一类报错通常是cx_oracle一些本地的配置的问题"></a>DPI-1047：这一类报错通常是cx_oracle一些本地的配置的问题</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cx_Oracle.DatabaseError: DPI-1047: Cannot locate a 64-bit Oracle Client library: <span class="string">&quot;The specified module could not be found&quot;</span></span><br></pre></td></tr></table></figure><p><strong>原因</strong> </p><ul><li>系统路径中没有添加Oracle的客户端路径  </li><li>系统安装的cx_Oracle版本与Oracle客户端版本不匹配（ x32 | x64 ）</li></ul><p><strong>解决方法</strong>  </p><p>如果路径有误:<br>&emsp;&emsp;添加相应的路径到环境变量中  </p><ul><li>Windows:<br>  PATH中添加…\instantclient_11_2文件夹即可</li><li>Linux:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#永久将该路径存入系统变量中</span></span><br><span class="line">sudo sh -c <span class="string">&quot;echo /opt/oracle/instantclient_21_1 &gt; /etc/ld.so.conf.d/oracle-instantclient.conf&quot;</span>  </span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>如果是版本不匹配，那么就重新下载位数匹配的客户端客户端再次进行尝试.  </li></ul><h3 id="ORA-12514：这一类报错通常是数据库服务方面的问题"><a href="#ORA-12514：这一类报错通常是数据库服务方面的问题" class="headerlink" title="ORA-12514：这一类报错通常是数据库服务方面的问题"></a>ORA-12514：这一类报错通常是数据库服务方面的问题</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cx_Oracle.DatabaseError: ORA-12514: TNS:listener does not currently know of service requested <span class="keyword">in</span> connect descriptor</span><br></pre></td></tr></table></figure><p><strong>原因</strong> </p><ul><li>Oracle连接服务名设置出错  </li></ul><p><strong>解决方法</strong>  </p><ul><li><p>修改Oracle连接的服务名，服务名可以通过oracle命令行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">PARAMETER</span> service_names</span><br><span class="line">NAME                                 TYPE        <span class="keyword">VALUE</span></span><br><span class="line"><span class="comment">------------------------------------ ----------- ------------------------------</span></span><br><span class="line">service_names                        string      orcl</span><br></pre></td></tr></table></figure><p>可以看到这里服务名就是orcl(一般默认服务名即为orcl).修改后应该就可以成功连接了.</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;前不久刚找到了第一份实习工作,刚进公司搞不了啥东西,也就熟悉一下环境,于是导师就给了我一份解析excel数据的活干.要求是将远程服务器中的数据拉到本地,并用python将数据进行解析,然后存入Oracle数据库中.网上查了一下,看上去使用最多的就是cx_Oracle这个库了,cx_Oracle配置起来较为复杂,刚开始的时候弄了半天才弄好.&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://mrilboom.github.io/tags/python/"/>
    
    <category term="Oracle" scheme="https://mrilboom.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>ssh密钥验证那些事</title>
    <link href="https://mrilboom.github.io/2021/08/28/SSHkey/"/>
    <id>https://mrilboom.github.io/2021/08/28/SSHkey/</id>
    <published>2021-08-27T17:16:12.000Z</published>
    <updated>2021-09-09T02:20:19.623Z</updated>
    
    <content type="html"><![CDATA[<hr><p>&emsp;&emsp;第一次接触到ssh密钥还是我在捣鼓树莓派的时候，当时拿着我的树莓派PI4B在搞项目，做一些IoT之类的小系统.当时需要上传各种驱动和相关代码进行测试，单纯的命令行进行ssh连接肯定会比较麻烦，但又感觉像<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">putty</a>、<a href="https://mobaxterm.mobatek.net/">MobaXterm</a>这类的又不够美观，于是就选择了Vscode来作为IDE，它里面的remote-ssh插件可以很方便的与linux服务器进行ssh连接，只需要配置好.config文件就可以进行连接了.但是有一个问题，每次连树莓派的时候我就都得输一次密码，有时候一不小心关了终端什么的，又得重新开一遍，挺麻烦的，于是就在网上找有没有什么方法可以让vscode记录密码自动登录或者可以避开密码验证什么的，然后我就找到了这个叫做SSH key 的东西.<span id="more"></span>  </p><hr><h2 id="SSH-key简单介绍"><a href="#SSH-key简单介绍" class="headerlink" title="SSH key简单介绍"></a>SSH key简单介绍</h2><p>&emsp;&emsp;通常我们进行SSH远程连接服务器是指定一个用户，然后再输入其密码，由服务器进行验证通过之后即可建立连接.<br>&emsp;&emsp;SSH key的验证方法有一些不同，它会同时产生两个密码(密钥)，其中一个被称作公钥，另一个被称作私钥.公钥，顾名思义，就是可以公开的密钥，交由服务器保管作为加密密钥和凭证，而私钥则是自己需要秘密保管的密钥.<br>&emsp;&emsp;SSH key采用了一种叫做”<a href="https://baike.baidu.com/item/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/1208652?fr=aladdin">非对称加密</a>“的方式进行通信加密  </p><img src="/2021/08/28/SSHkey/wiki.png" class>  <p>Nicobon，<a href="https://commons.wikimedia.org/w/index.php?curid=48484042">CC BY-SA 4.0</a></p><p>其默认算法是<a href="https://baike.baidu.com/item/RSA%E7%AE%97%E6%B3%95/263310?fromtitle=RSA&fromid=210678&fr=aladdin">rsa算法</a>，用户需要与服务器建立连接时，就向服务器发起请求，同时将公钥（<font color="#fdb933">由私钥可以很容易生成公钥，但是由公钥生成私钥以目前的算力来说几乎不可能</font>）捎带上去，服务器将该密钥与留存在自己机器上的公钥相比对，如果有一致的话，就会向请求主机发送一个用该公钥加密的“challenge request”，只有私钥才能解密该“challenge request”并作出相应的回应.<br>&emsp;&emsp;这一系列的过程中，只有公钥在网络上进行了传递，私钥一直保存在了本机，相比于输入密码，密码通过网络传递到服务器再进行验证的过程来说，无疑是更加安全的.</p><h2 id="SSH-key使用"><a href="#SSH-key使用" class="headerlink" title="SSH key使用"></a>SSH key使用</h2><p>&emsp;&emsp;一般在发行版的linux中，系统在第一次初始化的时候都会生成默认的公钥和私钥对，存放路径在/etc/ssh/ 文件夹下：</p><img src="/2021/08/28/SSHkey/sshkey.png" class title="sshkey"><p>里面预置了许多算法，如dsa、rsa、ecdsa等，一般的sshkeys都会使用rsa算法来生成密钥对.要使用该密钥对，可以进行如下操作:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/ssh/ssh_host_rsa_key.pub  ~/.ssh/id_rsa</span><br><span class="line">sudo chmod 600  ~/.ssh/id_rsa</span><br><span class="line"># 如果有特定的端口，请用 scp -P port 指定</span><br><span class="line">scp /etc/ssh/ssh_host_rsa_key   usr@host:~</span><br><span class="line"># 连接到服务器</span><br><span class="line">ssh usr@host</span><br><span class="line">sudo cat ~/ssh_host_rsa_key  &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>*<strong>注意*：id_rsa的权限（包括.ssh目录权限）不能过高，一般600即可，否则会报错</strong></p><img src="/2021/08/28/SSHkey/rsaerror.png" class title="error"><p>&emsp;&emsp;此外，生成ssh-key密钥对还可以采用SSH-keygen的命令，这里也更推荐使用这种方法来使用ssh密钥，该方法可以在该用户目录下生成.ssh文件夹.并在该文件夹下存放密钥，不必担心文件权限的问题.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C  &quot;your comments&quot; </span><br></pre></td></tr></table></figure><p>-t 指代加密方式，方式有[ dsa | ecdsa | ecdsa-sk | ed25519 | ed25519-sk | <strong>rsa</strong> ]默认方式即为rsa<br>-C 则为注释，会显式放在公钥末尾上，可以由此辨别公钥.<br>输入命令之后，系统会让你输入密钥对存放路径，默认放在~/.ssh/ 路径下，确定好历经之后就要求输入密钥的密码（一般直接回车两次跳过即可） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): /root/.ssh/id_rsa</span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /root/ssh/id_rsa</span><br><span class="line">Your public key has been saved in /root/ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>将公钥复制到需要登陆的服务器上的authorized_keys之后，即可使用该ssh密钥对进行ssh密钥方式登录.  </p><h2 id="github-SSH-key添加方式"><a href="#github-SSH-key添加方式" class="headerlink" title="github SSH key添加方式"></a>github SSH key添加方式</h2><p>&emsp;&emsp;早在去年，github就宣布了要取消<a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/">账户密码登录</a>的验证方式，并在今年8月13号正式实施.如今使用账号密码进行push时，github会直接拒绝验证，因此必须采取添加SSH密钥或其他的方式进行登录验证.在成功生成了SSH key密钥对之后，其实需要操作的步骤就很简单了</p><img src="/2021/08/28/SSHkey/addkey.png" class title="addkey">  <p>只需要将自己的id_rsa.pub中的内容复制，粘贴到key框中即可  </p><img src="/2021/08/28/SSHkey/addnew.png" class title="addnew"><p>可采用如下方法测试:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">Hi mrilboom! You&#x27;ve successfully authenticated， but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>之后登录github即可自动使用ssh密钥登录</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;第一次接触到ssh密钥还是我在捣鼓树莓派的时候，当时拿着我的树莓派PI4B在搞项目，做一些IoT之类的小系统.当时需要上传各种驱动和相关代码进行测试，单纯的命令行进行ssh连接肯定会比较麻烦，但又感觉像&lt;a href=&quot;https://www.chiark.greenend.org.uk/~sgtatham/putty/&quot;&gt;putty&lt;/a&gt;、&lt;a href=&quot;https://mobaxterm.mobatek.net/&quot;&gt;MobaXterm&lt;/a&gt;这类的又不够美观，于是就选择了Vscode来作为IDE，它里面的remote-ssh插件可以很方便的与linux服务器进行ssh连接，只需要配置好.config文件就可以进行连接了.但是有一个问题，每次连树莓派的时候我就都得输一次密码，有时候一不小心关了终端什么的，又得重新开一遍，挺麻烦的，于是就在网上找有没有什么方法可以让vscode记录密码自动登录或者可以避开密码验证什么的，然后我就找到了这个叫做SSH key 的东西.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://mrilboom.github.io/tags/Linux/"/>
    
    <category term="ssh" scheme="https://mrilboom.github.io/tags/ssh/"/>
    
    <category term="github" scheme="https://mrilboom.github.io/tags/github/"/>
    
  </entry>
  
</feed>
